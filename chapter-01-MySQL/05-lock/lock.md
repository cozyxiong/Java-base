# 锁
数据库锁可以按粒度、加锁算法、加锁策略、兼容性和其它等方面进行分类：
- 锁粒度
    - 行锁
        - 锁的是某行数据或行之间的间隙。由存储引擎实现，如 InnoDB
        - 开销大，加锁慢；会出现死锁；锁定粒度小，锁冲突概率低，并发度高
    - 表锁
        - 锁的是某个表。由 MySQL 的 SQL layer 层实现的
        - 开销小，加锁快；不会出现死锁；锁定粒度大，锁冲突概率高，并发度最低
    - 全局锁
        - 锁的是整个数据库。由 MySQL 的 SQL layer 层实现的
- 兼容性
    - 排它锁（写写互斥、读写互斥）
    - 共享锁（读读兼容）
    - 意向锁（意向锁间兼容）
- 其它锁
    - AUTO-INC 锁
- 加锁算法
    - Record Lock（记录锁）
    - Gap Lock（间隙锁）
    - Next-Key Lock（临键锁）
- 加锁策略
    - 悲观锁
    - 乐观锁

不同存储引擎支持的锁粒度：

|  存储引擎  |   行锁    | 表锁  |
|:------:|:------:|:---:|
| innoDB | √ |  √  |
| MyISAM |   |  √  |

## 全局锁
全局锁就是对整个数据库加锁，数据库处于只读状态。

```
-- 添加全局锁(FTWRL)
flush tables with read lock

-- 释放全局锁
unlock tables
```

阻塞
- 数据更新语句（insert、delete、update）
- 数据定义语句（alter table、drop table） 

使用场景
- 全库逻辑备份（mysqldump） 

危险性
- 主库上备份，在备份期间不能执行更新，业务基本停止
- 从库上备份，在备份期间从库不能执行主库同步过来的 binlog，导致主从延迟 

不同引擎备份
- MyISAM 引擎全局锁备份数据库
- InnoDB 引擎可重复读隔离级别下开启事务利用 Read View 备份数据库

## 表级锁
### 表锁
表锁就是对整个表加锁，表处于只读/写状态。
```
-- 添加共享锁(表共享读锁)
lock tables users read

-- 添加排他锁(表独占写锁)
lock tables users write

-- 释放表锁
unlock tables
```

分类
- 共享锁/表共享读锁
- 排他锁/表独占写锁

### 元数据锁
元数据锁（MDL）作用是防止 DML 和 DDL 并发冲突，操作表时隐式加锁，事务提交时释放。

分类
- MDL 写锁（DDL 操作）
- MDL 读锁（DML 操作） 

优先级
- MDL写锁>MDL读锁

### 意向锁
意向锁作用是快速判断表里是否有记录被加锁，操作记录时先对表隐式加锁。

分类
- 意向共享锁(记录添加共享锁）
- 意向排他锁(记录添加排他锁)

### AUTO-INC锁
AUTO-INC 锁作用是自动为自增字段赋递增值，插入记录时隐式加锁，插入完成后释放。在 MySQL 5.1.22 版本后，InnoDB 存储引擎提供了一种轻量级的锁来实现自增，插入记录时隐式加锁，字段赋值后即释放。

innodb_autoinc_lock_mode 参数
- = 0：采用 AUTO-INC 锁
- = 2：采用轻量级锁（性能高，但 binlog 记录操作命令时主从复制不一致）
- = 1：两种锁混着用（默认）
    - 如果能够确定插入记录的数量就采用轻量级锁
    - 不确定时就采用 AUTO-INC 锁

### 行级锁
行级锁就是对整条记录加锁，记录处于只读/写状态，加锁前先对表加对应的意向锁，事务提交时释放。
```
-- 添加共享锁
select ... lock in share mode

--添加排他锁
select ... for update
insert
update
delete
```

分类
- 共享锁/S锁
- 排他锁/X锁 

加锁算法（3种锁都是排它锁）
- Record Lock（记录锁）：锁记录本身 [ ]
- Gap Lock（间隙锁）：锁记录间隙 ( )
- Next-Key Lock（临键锁）：锁记录间隙+本身 ( ]

算法规则
- 加锁的对象是索引
- 加锁的基本单位是 next-key lock
- 加锁的规则本质是在最小范围内加锁
    - 唯一索引：索引唯一，找到后锁住即可
        - 在一些场景下退化成记录锁或间隙锁（搜哪括哪( )，搜到 [ or ] ）
          [ ]，退化成记录锁
          ( )，退化成间隙锁
          ( ]，不退化
    - 非唯一索引：索引不唯一，找到后因为还可插入相同索引，需要范围锁住
        - 对非唯一索引加锁不会退化（搜到后也要范围找 ( ] ）
    - 没有索引：无序，需全表锁住
        - 对该字段全部加锁且不会退化（锁全表 ( ] ）

防止锁全表

sql_safe_updates 设置为 1 ，开启安全更新模式：

update 语句必须满足如下条件之一才能执行成功：
- 使用 where，并且 where 条件中必须有索引列
- 使用 limit； 同时使用 where 和 limit，此时 where 条件中可以没有索引列

delete 语句必须满足以下条件能执行成功：
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

## 加锁机制
### 乐观锁
乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。

乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或时间戳。乐观锁的两种实现方式：
- 使用数据版本（version）记录对比机制
  - 当读取数据时，将 version 字段的值一同读出，数据每更新一次，对此 version 值加一。
- 使用时间戳（timestamp）记录对比机制
  - 在更新提交时检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，一致则 OK，否则为版本冲突。

```  
-- 0.开始事务
begin;
-- 1.查询出商品信息
SELECT stock FROM products WHERE product_id = 1
-- 2.修改商品 stock 为 2
update products set stock=2 where product_id = 1;
-- 3.提交事务
commit;
```
即在进行对 id=1 的记录进行修改的业务之前，并没有加锁，而是执行业务时才加锁，然后尝试修改。这就是典型的乐观锁策略。

### 悲观锁
悲观锁（一锁二查三更新）的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。在 MySQL 中，悲观锁依赖数据库提供的锁机制来实现，通过`select ... for update`来进行加锁
```
-- 0.开始事务
begin;
-- 1.查询出商品信息
SELECT stock FROM products WHERE product_id = 1 FOR UPDATE;
-- 2.修改商品 stock 为 
update products set stock=2 where product_id = 1;
-- 3.提交事务
commit;
```

即在进行对 id=1 的记录进行修改的业务之前，先通过 FOR UPDATE 的方式加锁，然后再进行修改。这就是典型的悲观锁策略。


## 锁问题
### 死锁
MyISAM 中是不会产生死锁的，因为 MyISAM 总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在 InnoDB 中，锁是逐步获得的，就造成了死锁的可能。

当两个及以上的事务，双方都在等待对方释放已经持有的锁或因为加锁顺序不一致造成循环等待锁资源，就会出现“死锁”。

例如：两个事务都拥有了同个范围的间隙锁后，同时准备往这个间隙中插入数据，而互相等待对方释放间隙锁，事务也一直无法结束，产生死锁。

常见的报错信息为：
```
Deadlock found when trying to get lock...
```

### 避免死锁
三种常见的避免死锁方式：
- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率

### 预防死锁
- innodb_lock_wait_timeout 等待锁超时回滚事务
  - 直观方法是在两个事务相互等待时，当一个等待时间超过设置的某一阀值时，对其中一个事务进行回滚，另一个事务就能继续执行。
- wait-for graph 算法来主动进行死锁检测 
  - 每当加锁请求无法立即满足需要并进入等待时，wait-for graph 算法都会被触发。
  - wait-for graph 要求数据库保存以下两种信息：
      - 锁的信息链表
      - 事务等待链表

### 解决死锁
- 等待事务超时，主动回滚
- 进行死锁检查，主动回滚某条事务，让别的事务能继续走下去

下面提供一种方法，解决死锁的状态:
```
-- 查看正在被锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;

-- 杀死该事务的线程
kill trx_mysql_thread_id;
```
![img.png](../images/lock-01.png)

## 总结
三个维度（数据库、表、行）的读写锁，数据库维度只有读锁，表维度有表的读写锁、元数据的读写锁和 AUTO-INC 锁，行维度有读写锁，对行添加读写锁时也要对表添加对应的读写意向锁。根据兼容性，读锁又称作共享锁，写锁称作排他锁。锁的规则：读读兼容，读写互斥，写写互斥，意向间兼容，间隙间兼容。

在可重复读隔离级别下，InnoDB 设计 MVCC 和锁机制都是为了最大程度上解决幻读问题，针对快照读（普通 select）通过 MVCC 解决幻读，针对当前读（加锁的 SELECT，或者对数据进行增删改都属于当前读）通过 next-key 锁解决幻读。判断加什么锁，就是判断加什么锁要锁住哪些区域才能避免幻读。
